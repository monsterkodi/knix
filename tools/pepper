#!/usr/bin/env coffee

ansi   = require 'ansi'
cursor = ansi process.stdout
fs     = require 'fs'
_      = require 'lodash'

argparse = require('argparse').ArgumentParser
parser   = new argparse
      version: '0.0.1'
      addHelp:true
      description: 'logpepper'

parser.addArgument [ 'input' ],
  help:              'input files or directories. default: current directory.'
  nargs:             '*'
  defaultValue:      '.'

parser.addArgument [ '-t', '--type' ],
    help:            'file type, default: coffee'
    defaultValue:    'coffee'

parser.addArgument [ '-o', '--output' ],
    help:            'output file, default: peppered.coffee'
    defaultValue:    'peppered.coffee'

parser.addArgument [ '-n', '--dryrun' ],
    help:            'just prints the peppered version'
    action:          'storeTrue'

args = parser.parseArgs()

strIndent = "    "

str = (o,indent="",visited=[]) ->
    if o == null
        return "<null>"
    t = typeof o
    if t == 'string'
        return o
    else if t == 'object'
        if o in visited
            if o.id? and typeof o.id == 'string' and o.localName? then return "<" + o.localName + "#" + o.id + ">"
            return "<visited>"
        protoname = o.constructor.name
        if not protoname? or protoname == ""
            if o.id? and typeof o.id == 'string' and o.localName?
                protoname = o.localName + "#"+o.id
            else
                protoname = "object"
        if protoname == 'Array'
            s = '[\n'
            visited.push o
            s += (indent+strIndent + str(v,indent+strIndent,visited) for v in o).join("\n")
            s += '\n'+indent+strIndent+']'
        else
            s = "<" + protoname + ">\n"
            visited.push o
            s += (indent+strIndent+k + ": " + str(o[k],indent+strIndent,visited) for k in Object.getOwnPropertyNames(o)).join("\n")
        return s+"\n"
    else if t == 'function'
        return "->"
    else
        return String(o) # plain values
    return "<???>"

log   = -> cursor.write((str(arg) for arg in arguments).join(" ")).write('\n')
error = -> cursor.yellow().bold().write('[ERROR] ').red().write((str(arg) for arg in arguments).join(" ")).reset().write('\n')

# error args

parseFile = (f) ->

    s = fs.readFileSync f,
        encoding: 'utf8'

    lines = s.split '\n'
    newlines = []

    log 'pepper:', f, lines.length

    for li in [0...lines.length]
        line = lines[li]
        logpat = /// ^[^#]* # begin of line and no comment sign
                      \s(log)\s
                      .*    # anything
                      $ /// # end of line
        if m = line.match(logpat)
            lines[li] = line.replace /(^[^#]*\s)(log)(\s)/, "$1_log '"+f+"', "+(li+1)+", "

    lines.join('\n')

collectFiles = (fod, set) ->
    stats = fs.statSync(fod)
    if stats.isDirectory()
        for f in fs.readdirSync(fod)
            collectFiles(fod+'/'+f, set)
    else if stats.isFile()
        if _.endsWith(fod, args.type)
          set.push(fod) if fod not in set

files = []
for i in args.input
    collectFiles i, files

result = ""
for f in files
    result += parseFile f

if args.dryrun
    log result
else
    fs.writeFileSync(args.output, result)
